// #include <stdint.h>
// #include <stddef.h>
// #include <stdio.h>
#include <gd.h>
#include <avif/avif.h>
// #include <cstddef>
#include <bits/stdc++.h>

// Mock gdIOCtx to simulate custom I/O
typedef struct {
    gdIOCtx ctx;
    const uint8_t* data;
    size_t size;
    size_t pos;
} MemoryCtx;

// Functions required by gdIOCtx to read from a memory buffer
static int memoryRead(gdIOCtx* ctx, void* buf, int size) {
    MemoryCtx* memCtx = (MemoryCtx*)ctx;
    if (memCtx->pos + size > memCtx->size) {
        size = memCtx->size - memCtx->pos;
    }
    memcpy(buf, memCtx->data + memCtx->pos, size);
    memCtx->pos += size;
    return size;
}

static void memoryCtxFree(gdIOCtx* ctx) {
    free(ctx);
}

// Helper function to create a gdIOCtx from a memory buffer
gdIOCtx* gdNewDynamicCtx(size_t size, const uint8_t* data) {
    MemoryCtx* ctx = (MemoryCtx*)malloc(sizeof(MemoryCtx));
    if (!ctx) return NULL;
    ctx->ctx.getC = NULL;
    ctx->ctx.putC = NULL;
    ctx->ctx.getBuf = memoryRead;
    ctx->ctx.putBuf = NULL;
    ctx->ctx.seek = NULL;
    ctx->ctx.tell = NULL;
    ctx->ctx.gd_free = memoryCtxFree;
    ctx->data = data;
    ctx->size = size;
    ctx->pos = 0;
    return (gdIOCtx*)ctx;
}

// Fuzzing entry point for libFuzzer
extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
    // Create a gdIOCtx from the fuzzed input data
    gdIOCtx* ctx = gdNewDynamicCtx(size, data);
    if (!ctx) return 0;

    // Call the vulnerable function in libgd
    gdImagePtr im = gdImageCreateFromAvifCtx(ctx);

    // Cleanup if the image was successfully created
    if (im) {
        gdImageDestroy(im);
    }

    // Free the gdIOCtx
    ctx->gd_free(ctx);

    return 0;
}
